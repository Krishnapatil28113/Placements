/*
# Question Link: https://leetcode.com/problems/next-permutation/
# Problem Statement: To find the next permutation of the array

# How to think:
1. Brute Force
* The most basic intuition that comes in our mind is to find out all the permutations of the array in a lexicographically sorted order
* Then, linearly traverse the array and search for the original array in the list of all permutations
* After finding, return the array at the next index

2. Better
* Use the inbuilt function next_permutation() of the STL in C++
* This will give the interviewer an idea that you know about STL

3. Optimal
* Suppose, we take an example array -> [2,1,5,4,3,0,0]
* Now, if we want to find the next permutation of this array, we will try to increase the number generated by this array like, [2,1,5,4,3,0,1] , [2,1,5,4,3,0,2] , etc.
* So basically, what we are doing is we are trying to rearrange the numbers from the end so that, the number getting generated
    is greater than the number generated by the previous array
* So, if we see; we can't arrange the elements 5,4,3,0,0 in any order to get greater element but we can do so for
    1,5,4,3,0,0 and convert it to 3,5,4,1,0,0
* So, the observation here is, that we can only generate a greater element if we encounter an element which is smaller than its next element,i.e, 1
* After finding that element, we now need to replace it with an element in the already traversed subarray,i.e, [5,4,3,0,0]
    which needs to be JUST greater than 1, i.e, 3
* Swap both the elements, i.e, 1 and 3
* Now, we need to arrange the rest of the elements in a sorted order so that we get the NEXT greater permutation
* So, we don't need to sort it manually, rather, we can just reverse the subarray, as we have already traversed it
    and we found that the array was already sorted in decresing order; so we just need to REVERSE it!

# Time Complexity: O(n)
# Space Complexity: O(1)
*/

#include <bits/stdc++.h>
using namespace std;

class Solution
{
public:
    void nextPermutation(vector<int> &arr)
    {
        int n = arr.size();

        int index = -1;
        for (int i = n - 2; i >= 0; i--)
        {
            if (arr[i] < arr[i + 1])
            {
                index = i;
                break;
            }
        }

        if (index == -1)
        {
            reverse(arr.begin(), arr.end());
        }
        else
        {
            for (int i = n - 1; i > index; i--)
            {
                if (arr[i] > arr[index])
                {
                    swap(arr[i], arr[index]);
                    break;
                }
            }

            reverse(arr.begin() + index + 1, arr.end());
        }
    }
};